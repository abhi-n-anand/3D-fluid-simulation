<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <style>
    body {
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
    }
    h1, h2, h3, h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
<title> Abhi Anand | CS 184</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<br />
<h1 align="middle">Assignment 4: ClothSim</h1>
    <h2 align="middle">Abhi Anand</h2>

    <div class="padded">
        <p>In this project, I implemented a cloth simulator that was built out of a grid of particles (called point masses) and springs.
        The first part of the project involved setting up a grid representation of a cloth that had springs that were able to incorporate structural, bending, and shearing constraints.
      The second part of the project involved establishing a simulation for us to view the effects of the constraints in real-time. This involved accounting for spring correction and all forces acting
    on the particles. The third part of this project involved accounting for collisions between primitive objects and the cloth. The fourth part of the project involved using hashing to efficiently account for
  collisions between the cloth and another part of itself. The last part of the project invovled implementing diffuse shading, Blinn-Phong shading, texture mapping, bump and displacement mapping, and mirror shading.
Overall, this project helped establish my mathematical understanding of the various concepts taught in class. The project involved a lot of vector math, so being able to visualize this was key to reinforcing my understanding. I am also
significantly more comfortable with GLSL.  </p>

    <h2 align="middle">Part 1: Masses and Springs</h2>

        <p>This part of the project was centered on creating a mesh composed of point masses and springs. The point masses were added in row-major order, looping over both the x and y axes. The mass position is
        evaluated on a case-by-case basis. If the orientation is vertical, the z coordinate of the point mass is a random number between -1/1000 and 1/1000. If the orientation is horizontal, the y coordinate is simply 1.0.
      Then, I check to see if point masses are pinned and set flags for future reference. Last but not least, I add springs between the point masses as dictated by the spec for the three types of constraints: Structural, Bending, and Shearing. </p>
        <div align="middle">
          <table style="width=100%">
            <tr>
              <td>
                <img src="images/structbconstraints.png" align="middle" width="400px"/>
                <figcaption align="middle">Only structural and bending constraints.</figcaption>
              </td>
              <td>
                <img src="images/shearconstraints.png" align="middle" width="400px"/>
                <figcaption align="middle">Only shearing constraints.</figcaption>
              </td>
            </tr>
        </table>
      </div>

        <div align="middle">
          <table style="width=100%">
            <tr>
              <td>
                <img src="images/allconstraints.png" align="middle" width="400px"/>
                <figcaption align="middle">All constraints.</figcaption>
              </td>
            </tr>
          </table>
        </div>



  <h2 align="middle">Part 2: Simulation via Numerical Integration</h2>
  <p> In this section, I implemented code that allowed me to simulate cloth movement in real-time. This involved accouting for two kinds of forces: external and correction.
    External forces exert a uniform amount of force on all point masses. The correction forces allow for realistic movement of the point-masses in relation to the types of springs
    the point masses are connected with. Additionally, another correction force that had to be accounted for was the idea that a spring should not extend past 1.1 times its rest length in the previous time step.
    Thus, to implement this part of the project, I began by establishing the total force exerted on a point mass. I then used Hooke's Law to calculate the constraints imposed by the spring type. Then, I update the positions
    of the point masses if the point mass is not pinned using the forces from above. Last but not least, I account for the Provost paper and reestablish distances as necessary.
</p>
<p> Varying the effects of ks. ks measures a spring's stiffness. This is a constant used in Hooke's Law and is applied to all point masses. ks is inversely correlated with stretchiness of springs.
  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/ks3.png" align="middle" width="400px"/>
          <figcaption align="middle">ks = 1000 N/m.</figcaption>
        </td>
        <td>
          <img src="images/ks4.png" align="middle" width="400px"/>
          <figcaption align="middle">ks = 1000 N/m.</figcaption>
        </td>
      </tr>
  </table>
  </div>

  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/ks1.png" align="middle" width="400px"/>
          <figcaption align="middle">ks = 5,000 N/m.</figcaption>
        </td>
        <td>
          <img src="images/ks2.png" align="middle" width="400px"/>
          <figcaption align="middle">ks = 5,000 N/m.</figcaption>
        </td>
      </tr>
  </table>
  </div>

  <p> The top two images display a more elastic material (when the ks is low) in comparison to the bottom two images which represent a stiffer material (when the ks is high). This is because the springs are not able to move as freely in the bottom two photos in comparison to the top two. </p>

<p> Varying the effects of density. Density plays a role when we calculate the mass of each point within the cloth. Density is positively correlated with force if mass remains constant. Looking at the pinned cloth, we see that a lower density
  has less of a dip at the top in the final resting state when compared to when the cloth is simulated with a higher density.

  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/density1.png" align="middle" width="400px"/>
          <figcaption align="middle">Density = 1 g/cm^2.</figcaption>
        </td>
        <td>
          <img src="images/density2.png" align="middle" width="400px"/>
          <figcaption align="middle">Density = 1 g/cm^2.</figcaption>
        </td>
      </tr>
    </table>
  </div>

      <div align="middle">
        <table style="width=100%">
      <br>
      <tr>
        <td>
          <img src="images/density3.png" align="middle" width="400px"/>
          <figcaption align="middle">Density = 50 g/cm^2.</figcaption>
        </td>
        <td>
          <img src="images/density4.png" align="middle" width="400px"/>
          <figcaption align="middle">Density = 50 g/cm^2.</figcaption>
        </td>
      </tr>
    </table>
  </div>

  <p> The lower density (top two images) shows a lot smaller droop in the cloth. The higher density (bottom two images) shows a larger droop in the cloth. Additionally, the cloth with greater density seems to have thicker and more prominent folds. There is also a significantly different color representation between the two densities as revealed by the texture.</p>

  <p> Varying the effects of damping. The damping value has influence when we account for energy loss. A higher damping value means more energy is lost within each timestep, which terminates the simulation more quickly as the damping value increases.</p>
 </p>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/damping1.png" align="middle" width="400px"/>
         <figcaption align="middle">Damping = 0.01%.</figcaption>
       </td>
       <td>
         <img src="images/damping2.png" align="middle" width="400px"/>
         <figcaption align="middle">Damping = 0.01%.</figcaption>
       </td>
     </tr>
   </table>
 </div>

     <div align="middle">
       <table style="width=100%">
     <br>
     <tr>
       <td>
         <img src="images/damping3.png" align="middle" width="400px"/>
         <figcaption align="middle">Damping = 1%.</figcaption>
       </td>
       <td>
         <img src="images/damping4.png" align="middle" width="400px"/>
         <figcaption align="middle">Damping = 1%.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/finalstate.png" align="middle" width="400px"/>
         <figcaption align="middle">Final resting state.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <h2 align="middle">Part 3: Handling Collisions with Other Objects</h2>
 <p> In this section, I handled collisions between the cloth and a plane and the cloth and a sphere. For the sphere collisions, I check each point and determine whether the point lies within the sphere's volume by comparing the distance between the point mass and the origin. If the distance is less than the radius, I know that the cloth and sphere have collided. I then
 update the position to allow the cloth to rest on the surface of the sphere. I account for a correction that incorporates the impact of the cloth on the sphere and the force of friction while adding a small delta that allows for the
cloth to rest slightly above the tangent point. For the plane collisions, I checked to see if the point mass in question crossed the two sides of the plane by comparing the signs of the dot product between the normal vector and the vector that is the difference between the point's position and the origin. If there is a difference, I know that the plane has been crossed.
I then apply a correction so that the cloth rests at a small offset above the contact point with the plane and account for the impact between the cloth and the plane itself. </p>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/sphere1.png" align="middle" width="400px"/>
         <figcaption align="middle">Cloth on sphere with ks = 500 N/m.</figcaption>
       </td>
       <td>
         <img src="images/sphere2.png" align="middle" width="400px"/>
         <figcaption align="middle">Cloth on sphere with ks = 5000 N/m.</figcaption>
       </td>
     </tr>
   </table>
 </div>

     <div align="middle">
       <table style="width=100%">
     <br>
     <tr>
       <td>
         <img src="images/sphere3.png" align="middle" width="400px"/>
         <figcaption align="middle">Cloth on sphere with ks = 500000 N/m.</figcaption>
       </td>
       <td>
         <img src="images/plane.png" align="middle" width="400px"/>
         <figcaption align="middle">Cloth on plane, ks = 500 N/m.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <h2 align="middle">Part 4: Handling Self-Collisions</h2>
 <p> In this section, I handled cases where some point masses within the cloth would interact with other point masses. Because finding points to test for self-intersection is inefficient if we were to continuously loop over all points and the points near it, I implemented a hashing function.
   This hash function maps a given position to a bucket. I used a polynomial: 31x^2 + 31y + z to ensure the uniqueness of the hash and to minimize collisions. Then, I add point masses to the mapping by evaluating their hash and obtaining a corresponding hashKey. After this, I check for self-collisions. I make sure
   to not compare the same point mass by checking whether the x, y, and z coordinates of the two point masses in quesiton are the same. If they are different, I check to see if the distance is less than twice the thickness. If this is not true, I establish a correction vector that adjusts the points to create said distance. Last but not least,
   the final position is established by averaging the desired change and by scaling it down with regards to the number of simulation steps. A fault with this idea is that we only check within a specific bucket, which can lead to an effect known as clipping.
 </p>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/finalDragon2.png" align="middle" width="400px"/>
         <figcaption align="middle">Initial folding.</figcaption>
       </td>
       <td>
         <img src="images/finalDragon3.png" align="middle" width="400px"/>
         <figcaption align="middle">Halfway through folding.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/allconstraints.png" align="middle" width="400px"/>
         <figcaption align="middle">Resting state.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/allconstraints.png" align="middle" width="400px"/>
         <figcaption align="middle">Control image before density and ks comparison. Density = 1 g/cm^2. ks = 500.</figcaption>
       </td>
     </tr>
   </table>
 </div>
     <div align="middle">
       <table style="width=100%">
     <br>
     <tr>
       <td>
         <img src="images/finalBunny0.png" align="middle" width="400px"/>
         <figcaption align="middle">Varying density. Density = 100 g/cm^2.</figcaption>
       </td>
       <td>
         <img src="images/finalBunny1.png" align="middle" width="400px"/>
         <figcaption align="middle">Varying ks. ks = 500.</figcaption>
       </td>
     </tr>
   </table>
 </div>

<p> Discussion on what density and ks do to image. </p>

<h2 align="middle">Part 5: Shaders</h2>
<p> In this section, I implemented various types of shading. I started with diffuse shading, then implemented Blinn-Phong shading, texture mapping,
  bump and displacement mapping, and mirror shading. This was done using GLSL which uses vertex shaders and fragment shaders. The former transforms vertices while the latter
  affects fragments post-rasterization. An example of a vertex shader is displacement mapping (will be shown below). Vertex shading uses Phong shading specifically whereas fragment shading
  incorporates teh Blinn-Phong shading model.

  The Blinn-Phong shading model essentially incorporates ambient lighting, diffuse lighting, and specular highlights when calculating the illumination of a surface. This is best seen through the equation below:

   <div align="middle">
     <table style="width=100%">
       <tr>
         <td>
           <img src="images/finalDragon2.png" align="middle" width="400px"/>
           <figcaption align="middle">Blinn-Phong Equation. Terms are ambient lighting, diffuse lighting, and specular highlights (established by plus signs).</figcaption>
         </td>
       </tr>
     </table>
   </div>



<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/finalDragon2.png" align="middle" width="400px"/>
        <figcaption align="middle">Ambient.</figcaption>
      </td>
      <td>
        <img src="images/finalDragon3.png" align="middle" width="400px"/>
        <figcaption align="middle">Diffuse.</figcaption>
      </td>
    </tr>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/finalDragon2.png" align="middle" width="400px"/>
        <figcaption align="middle">Specular.</figcaption>
      </td>
      <td>
        <img src="images/finalDragon3.png" align="middle" width="400px"/>
        <figcaption align="middle">All Blinn-Phong components.</figcaption>
      </td>
    </tr>
  </table>
</div>

</body>
</html>
