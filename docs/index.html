<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <style>
    body {
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
    }
    h1, h2, h3, h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
<title> Abhi Anand | CS 184</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<br />
<h1 align="middle">Assignment 4: ClothSim</h1>
    <h2 align="middle">Abhi Anand</h2>

    <div class="padded">
        <p>In this project, I implemented a cloth simulator that was built out of a grid of particles (called point masses) and springs.
        The first part of the project involved setting up a grid representation of a cloth that had springs that were able to incorporate structural, bending, and shearing constraints.
      The second part of the project involved establishing a simulation for us to view the effects of the constraints in real-time. This involved accounting for spring correction and all forces acting
    on the particles. The third part of this project involved accounting for collisions between primitive objects and the cloth. The fourth part of the project involved using hashing to efficiently account for
  collisions between the cloth and another part of itself. The last part of the project invovled implementing diffuse shading, Blinn-Phong shading, texture mapping, bump and displacement mapping, and mirror shading.
Overall, this project helped establish my mathematical understanding of the various concepts taught in class. The project involved a lot of vector math, so being able to visualize this was key to reinforcing my understanding. I am also
significantly more comfortable with GLSL.  </p>

    <h2 align="middle">Part 1: Masses and Springs</h2>

        <p>This part of the project was centered on creating a mesh composed of point masses and springs. The point masses were added in row-major order, looping over both the x and y axes. The mass position is
        evaluated on a case-by-case basis. If the orientation is vertical, the z coordinate of the point mass is a random number between -1/1000 and 1/1000. If the orientation is horizontal, the y coordinate is simply 1.0.
      Then, I check to see if point masses are pinned and set flags for future reference. Last but not least, I add springs between the point masses as dictated by the spec for the three types of constraints: Structural, Bending, and Shearing. </p>
        <div align="middle">
          <table style="width=100%">
            <tr>
              <td>
                <img src="images/structbconstraints.png" align="middle" width="400px"/>
                <figcaption align="middle">Only structural and bending constraints.</figcaption>
              </td>
              <td>
                <img src="images/shearconstraints.png" align="middle" width="400px"/>
                <figcaption align="middle">Only shearing constraints.</figcaption>
              </td>
            </tr>
        </table>
      </div>

        <div align="middle">
          <table style="width=100%">
            <tr>
              <td>
                <img src="images/allconstraints.png" align="middle" width="400px"/>
                <figcaption align="middle">All constraints.</figcaption>
              </td>
            </tr>
          </table>
        </div>



  <h2 align="middle">Part 2: Simulation via Numerical Integration</h2>
  <p> In this section, I implemented code that allowed me to simulate cloth movement in real-time. This involved accouting for two kinds of forces: external and correction.
    External forces exert a uniform amount of force on all point masses. The correction forces allow for realistic movement of the point-masses in relation to the types of springs
    the point masses are connected with. Additionally, another correction force that had to be accounted for was the idea that a spring should not extend past 1.1 times its rest length in the previous time step.
    Thus, to implement this part of the project, I began by establishing the total force exerted on a point mass. I then used Hooke's Law to calculate the constraints imposed by the spring type. Then, I update the positions
    of the point masses if the point mass is not pinned using the forces from above. Last but not least, I account for the Provost paper and reestablish distances as necessary.
</p>
<p> Varying the effects of ks. ks measures a spring's stiffness. This is a constant used in Hooke's Law and is applied to all point masses. ks is inversely correlated with stretchiness of springs.
  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/ks3.png" align="middle" width="400px"/>
          <figcaption align="middle">ks = 1000 N/m.</figcaption>
        </td>
        <td>
          <img src="images/ks4.png" align="middle" width="400px"/>
          <figcaption align="middle">ks = 1000 N/m.</figcaption>
        </td>
      </tr>
  </table>
  </div>

  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/ks1.png" align="middle" width="400px"/>
          <figcaption align="middle">ks = 5,000 N/m.</figcaption>
        </td>
        <td>
          <img src="images/ks2.png" align="middle" width="400px"/>
          <figcaption align="middle">ks = 5,000 N/m.</figcaption>
        </td>
      </tr>
  </table>
  </div>

  <p> The top two images display a more elastic material (when the ks is low) in comparison to the bottom two images which represent a stiffer material (when the ks is high). This is because the springs are not able to move as freely in the bottom two photos in comparison to the top two. </p>

<p> Varying the effects of density. Density plays a role when we calculate the mass of each point within the cloth. Density is positively correlated with force if mass remains constant. Looking at the pinned cloth, we see that a lower density
  has less of a dip at the top in the final resting state when compared to when the cloth is simulated with a higher density.

  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/density1.png" align="middle" width="400px"/>
          <figcaption align="middle">Density = 1 g/cm^2.</figcaption>
        </td>
        <td>
          <img src="images/density2.png" align="middle" width="400px"/>
          <figcaption align="middle">Density = 1 g/cm^2.</figcaption>
        </td>
      </tr>
    </table>
  </div>

      <div align="middle">
        <table style="width=100%">
      <br>
      <tr>
        <td>
          <img src="images/density3.png" align="middle" width="400px"/>
          <figcaption align="middle">Density = 50 g/cm^2.</figcaption>
        </td>
        <td>
          <img src="images/density4.png" align="middle" width="400px"/>
          <figcaption align="middle">Density = 50 g/cm^2.</figcaption>
        </td>
      </tr>
    </table>
  </div>

  <p> The lower density (top two images) shows a lot smaller droop in the cloth. The higher density (bottom two images) shows a larger droop in the cloth. Additionally, the cloth with greater density seems to have thicker and more prominent folds. There is also a significantly different color representation between the two densities as revealed by the texture.</p>

  <p> Varying the effects of damping. The damping value has influence when we account for energy loss. A higher damping value means more energy is lost within each timestep, which terminates the simulation more quickly as the damping value increases.</p>
 </p>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/damping1.png" align="middle" width="400px"/>
         <figcaption align="middle">Damping = 0.01%.</figcaption>
       </td>
       <td>
         <img src="images/damping2.png" align="middle" width="400px"/>
         <figcaption align="middle">Damping = 0.01%.</figcaption>
       </td>
     </tr>
   </table>
 </div>

     <div align="middle">
       <table style="width=100%">
     <br>
     <tr>
       <td>
         <img src="images/damping3.png" align="middle" width="400px"/>
         <figcaption align="middle">Damping = 1%.</figcaption>
       </td>
       <td>
         <img src="images/damping4.png" align="middle" width="400px"/>
         <figcaption align="middle">Damping = 1%.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/finalstate.png" align="middle" width="400px"/>
         <figcaption align="middle">Final resting state.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <h2 align="middle">Part 3: Handling Collisions with Other Objects</h2>
 <p> In this section, I handled collisions between the cloth and a plane and the cloth and a sphere. For the sphere collisions, I check each point and determine whether the point lies within the sphere's volume by comparing the distance between the point mass and the origin. If the distance is less than the radius, I know that the cloth and sphere have collided. I then
 update the position to allow the cloth to rest on the surface of the sphere. I account for a correction that incorporates the impact of the cloth on the sphere and the force of friction while adding a small delta that allows for the
cloth to rest slightly above the tangent point. For the plane collisions, I checked to see if the point mass in question crossed the two sides of the plane by comparing the signs of the dot product between the normal vector and the vector that is the difference between the point's position and the origin. If there is a difference, I know that the plane has been crossed.
I then apply a correction so that the cloth rests at a small offset above the contact point with the plane and account for the impact between the cloth and the plane itself. </p>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/sphere1.png" align="middle" width="400px"/>
         <figcaption align="middle">Cloth on sphere with ks = 500 N/m.</figcaption>
       </td>
       <td>
         <img src="images/sphere2.png" align="middle" width="400px"/>
         <figcaption align="middle">Cloth on sphere with ks = 5000 N/m.</figcaption>
       </td>
     </tr>
   </table>
 </div>

     <div align="middle">
       <table style="width=100%">
     <br>
     <tr>
       <td>
         <img src="images/sphere3.png" align="middle" width="400px"/>
         <figcaption align="middle">Cloth on sphere with ks = 50000 N/m.</figcaption>
       </td>
       <td>
         <img src="images/plane.png" align="middle" width="400px"/>
         <figcaption align="middle">Cloth on plane, ks = 500 N/m.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <p> As you can see, increasing the ks directly correlates with the elasticity of the material. In the first picture, we see that with a ks of 500 N/m, the cloth extends significantly further than the ball. As the ks increases to 500000 N/m, the material is unable to cover the sphere and instead rests awkwardly on top of it.
 We can also note the differences in colors between the three images-- the first is primarily heues of pink and orange while the third is significantly more green than before.   </p>

 <h2 align="middle">Part 4: Handling Self-Collisions</h2>
 <p> In this section, I handled cases where some point masses within the cloth would interact with other point masses. Because finding points to test for self-intersection is inefficient if we were to continuously loop over all points and the points near it, I implemented a hashing function.
   This hash function maps a given position to a bucket. I used a polynomial: 31x^2 + 31y + z to ensure the uniqueness of the hash and to minimize collisions. Then, I add point masses to the mapping by evaluating their hash and obtaining a corresponding hashKey. After this, I check for self-collisions. I make sure
   to not compare the same point mass by checking whether the x, y, and z coordinates of the two point masses in quesiton are the same. If they are different, I check to see if the distance is less than twice the thickness. If this is not true, I establish a correction vector that adjusts the points to create said distance. Last but not least,
   the final position is established by averaging the desired change and by scaling it down with regards to the number of simulation steps. A fault with this idea is that we only check within a specific bucket, which can lead to an effect known as clipping.
 </p>

<p> These 3 photos were taken at density 15 g/cm^2 and ks 5000 N/m. </p>
 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/fold2.png" align="middle" width="400px"/>
         <figcaption align="middle">Initial folding.</figcaption>
       </td>
       <td>
         <img src="images/fold3.png" align="middle" width="400px"/>
         <figcaption align="middle">Halfway through folding.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <div align="middle">
   <table style="width=100%">
     <tr>
       <td>
         <img src="images/fold1.png" align="middle" width="400px"/>
         <figcaption align="middle">Resting state.</figcaption>
       </td>
     </tr>
   </table>
 </div>

 <p> These 3 photos were taken at density 50 g/cm^2 and ks 5000 N/m. </p>
  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/fold5.png" align="middle" width="400px"/>
          <figcaption align="middle">Initial folding.</figcaption>
        </td>
        <td>
          <img src="images/fold6.png" align="middle" width="400px"/>
          <figcaption align="middle">Halfway through folding.</figcaption>
        </td>
      </tr>
    </table>
  </div>

  <div align="middle">
    <table style="width=100%">
      <tr>
        <td>
          <img src="images/fold4.png" align="middle" width="400px"/>
          <figcaption align="middle">Resting state.</figcaption>
        </td>
      </tr>
    </table>
  </div>

  <p> These 3 photos were taken at density 15 g/cm^2 and ks 50000 N/m. </p>
   <div align="middle">
     <table style="width=100%">
       <tr>
         <td>
           <img src="images/fold7.png" align="middle" width="400px"/>
           <figcaption align="middle">Initial folding.</figcaption>
         </td>
         <td>
           <img src="images/fold8.png" align="middle" width="400px"/>
           <figcaption align="middle">Halfway through folding.</figcaption>
         </td>
       </tr>
     </table>
   </div>

   <div align="middle">
     <table style="width=100%">
       <tr>
         <td>
           <img src="images/fold9.png" align="middle" width="400px"/>
           <figcaption align="middle">Resting state.</figcaption>
         </td>
       </tr>
     </table>
   </div>
<p> With regards to modifying density, the first thing I noticed was that the simulation took slightly longer to run as density increased. Second, from the pictures above, we see that the higher density cloth seems to have a signiicantly higher amount of wrinkes. Additionally, there seems to be more clipping present as the cloth folds over itself more. An interesting
  observation was that the cloth's folds seemed to vary in size more in the 50 g/cm^2 density round than before. The resting states of the two images seem relatively comparable, with the only major distinciton in the size of the folds being slightly larger in the more dense resting state image. With regards to modifying ks, I noticed that a higher ks resulted in
faster simulations. Additionally, from the images above, it is evident that when compared to the control (first three images), the higher ks value resulted in a cloth simulation that had an insane amount of wrinkles present. The folds were also significantly larger in this simulation because the material was so stiff. This resulted in a resting state that had significantly less clipping but
at the same time, less and wider folds. </p>

<h2 align="middle">Part 5: Shaders</h2>
<p> In this section, I implemented various types of shading. I started with diffuse shading, then implemented Blinn-Phong shading, texture mapping,
  bump and displacement mapping, and mirror shading. This was done using GLSL which uses vertex shaders and fragment shaders. The former transforms vertices while the latter
  affects fragments post-rasterization. An example of a vertex shader is displacement mapping (will be shown below). Vertex shading uses Phong shading specifically whereas fragment shading
  incorporates teh Blinn-Phong shading model.

  The Blinn-Phong shading model essentially incorporates ambient lighting, diffuse lighting, and specular highlights when calculating the illumination of a surface. This is best seen through the equation below:

   <div align="middle">
     <table style="width=100%">
       <tr>
         <td>
           <img src="images/eqn.png" align="middle" width="400px"/>
           <figcaption align="middle">Blinn-Phong Equation. Terms are ambient lighting, diffuse lighting, and specular highlights (differentiated by plus signs).</figcaption>
         </td>
       </tr>
     </table>
   </div>



<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/p1.png" align="middle" width="400px"/>
        <figcaption align="middle">Ambient, ka = 0.05.</figcaption>
      </td>
      <td>
        <img src="images/p2.png" align="middle" width="400px"/>
        <figcaption align="middle">Ambient, ka = 0.05.</figcaption>
      </td>
    </tr>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/p3.png" align="middle" width="400px"/>
        <figcaption align="middle">Diffuse, kd = 0.05.</figcaption>
      </td>
      <td>
        <img src="images/p4.png" align="middle" width="400px"/>
        <figcaption align="middle">Diffuse, kd = 0.05.</figcaption>
      </td>
    </tr>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/p5.png" align="middle" width="400px"/>
        <figcaption align="middle">Specular, ks = 0.3.</figcaption>
      </td>
      <td>
        <img src="images/p6.png" align="middle" width="400px"/>
        <figcaption align="middle">Specular, ks = 0.3.</figcaption>
      </td>
    </tr>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/p7.png" align="middle" width="400px"/>
        <figcaption align="middle">All components.</figcaption>
      </td>
      <td>
        <img src="images/p8.png" align="middle" width="400px"/>
        <figcaption align="middle">All components.</figcaption>
      </td>
    </tr>
  </table>
</div>

<p> Now, texture mapping. This was done using the GLSL's texture function. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/tex1.png" align="middle" width="400px"/>
        <figcaption align="middle">Texture mapped.</figcaption>
      </td>
      <td>
        <img src="images/tex2.png" align="middle" width="400px"/>
        <figcaption align="middle">Texture mapped.</figcaption>
      </td>
    </tr>
  </table>
</div>

<p> Now, bump and displacement mapping. For both mappings, the fragment shader is changed to calculate the texture using surface normals.
For displacement mapping specifically, the vertex shader is also modified to displace the actual vertices of the shape. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/bump161.png" align="middle" width="400px"/>
        <figcaption align="middle">Bump mapped, coarseness 16.</figcaption>
      </td>
      <td>
        <img src="images/bump162.png" align="middle" width="400px"/>
        <figcaption align="middle">Bump mapped, coarseness 16.</figcaption>
      </td>
    </tr>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/bump1281.png" align="middle" width="400px"/>
        <figcaption align="middle">Bump mapped, coarseness 128.</figcaption>
      </td>
      <td>
        <img src="images/bump1282.png" align="middle" width="400px"/>
        <figcaption align="middle">Bump mapped, coarseness 128.</figcaption>
      </td>
    </tr>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/disp161.png" align="middle" width="400px"/>
        <figcaption align="middle">Displacement mapped, coarseness 16.</figcaption>
      </td>
      <td>
        <img src="images/disp162.png" align="middle" width="400px"/>
        <figcaption align="middle">Displacement mapped, coarseness 16.</figcaption>
      </td>
    </tr>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/disp1281.png" align="middle" width="400px"/>
        <figcaption align="middle">Displacement mapped, coarseness 128.</figcaption>
      </td>
      <td>
        <img src="images/disp1282.png" align="middle" width="400px"/>
        <figcaption align="middle">Displacement mapped, coarseness 128.</figcaption>
      </td>
    </tr>
  </table>
</div>
<p> I used texture_4 for my bump and displacement mapping. The main differences to note are that the bump mapping doesn't affect the
silhouette of the sphere & cloth while displacement mapping does. It's hard to discern the difference on the cloth in the initial state, but we see the
vertical lines present on the sphere & cloth when covering the sphere in the displacement mapped images but not in the bump mapped images. With regards to the change in coarseness across the
bump mapped images, we see that a greater coarseness is privy to more detail in the resting state. There are more wrinkles present, which implies a more accurate rendering. With regards to the change in coarseness across the
displacement mapped images, we see again, greater detail in the texture, but also greater detail in the illumination. What I mean by this is that from a texture perspective, the details of the texture we've used for the displacement
mapping have more wrinkles, greater shading detail, and easily-discernable features. With regards to the illumination, we see less light in the coarseness 128 images, giving a more representative color to the displacement mapped image that
results from the simulation. </p>

<p> Last but not least, mirror shading. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/mirror1.png" align="middle" width="400px"/>
        <figcaption align="middle">Mirror shading.</figcaption>
      </td>
      <td>
        <img src="images/mirror2.png" align="middle" width="400px"/>
        <figcaption align="middle">Mirror shading.</figcaption>
      </td>
    </tr>
  </table>
</div>

</body>
</html>
